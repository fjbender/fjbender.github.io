[{"categories":null,"content":"Klarna One UK Checkout Experience In case you have ever wondered what the checkout experience looks like in live mode, here are two screen shots: ","date":"2023-09-01","objectID":"/klarna-one-checkout-experience/:0:0","tags":null,"title":"Klarna One Checkout Experience","uri":"/klarna-one-checkout-experience/"},{"categories":null,"content":"Multiple Webhook URLs in One Payment or Order ","date":"2023-01-17","objectID":"/multiple-webhook-urls-in-one-payment-or-order/:0:0","tags":null,"title":"Multiple Webhook Urls in One Payment or Order","uri":"/multiple-webhook-urls-in-one-payment-or-order/"},{"categories":null,"content":"The problem for merchants Sometimes, a merchant wants to inform multiple systems about the status changes (or the inception) of a payment (or order - we use payment synonymously throughout this article). For instance, the merchant might use a SaaS Order Management System (OMS) and Shopware 6. Whenever a new payment reaches the state of paid, the merchant wants this information to go into their SaaS OMS, where they then pull the payment and use the information in the metadata field to pull the order from the Shopware API. This approach is beneficial, because the merchant doesn’t have to write complicated export logic in Shopware, but rather just pulls orders that definitively are paid. This, however, does not work currently. The merchant might overwrite the webhookUrlGenerator component in the Shopware 6 plugin to divert webhooks to their SaaS OMS, but that would break a lot of functionality in Shopware, as the webhook is not available there anymore. ","date":"2023-01-17","objectID":"/multiple-webhook-urls-in-one-payment-or-order/:1:0","tags":null,"title":"Multiple Webhook Urls in One Payment or Order","uri":"/multiple-webhook-urls-in-one-payment-or-order/"},{"categories":null,"content":"The problem for technology integrators With the increasing focus on technology (SaaS) integrations, the restrictions caused by webhooks not calling to multiple platforms have become more obvious. Consequently, platforms not creating transactions are left without real-time updates on transactions, customers, subscriptions and more. Examples of platforms that need real-time data updates within the SaaS landscape are: Marketing Automation tools (Active Campaign, Klaviyo) Workflow automation systems (Zapier, Make) CRM-systems (Freshworks, Hubspot) At present, if we were to build a non-transaction creating Technology integration we would be forced to construct a (mirror) middleware database as a workaround. The needed Mollie data (transactions, customers etc.) would be stored within this data base. By means of the List function within our API the data would be updated every X amount of time, depending on the need of the integration. Although this might be a temporary solution, this set up has the following drawbacks: Increased Security risk - As we are currently not able to host the mirror data bases within Mollie we are obliged to host the databases with a third party (third party integrator or contractor of third party integrator). This set-up increases the risk of a data breach and therefore reputation risk of Mollie. “Mitigation of this risk is executed carefully and diligently, but that uses time and resources and slows down the process. No real-time updates - As the amount of data that is processed within a List request is too great to do an (almost) constant pull request, the requests are carried out within certain timeframes. Consequently, the data shown within the integration and possible actions depending on the changes of data will always have a lag. Strenuous use of Mollie data base - Due to the fact that pulling targeted updates is not possible, we are compelled to update all available data via a List request. This results in unnecessary use of the Mollie data base. Fall-off of historic data due to pagination - As the Mollie API employs Pagination with the List request, we are restricted to updates of the most recent 250 transactions within an organisation. This limits the quality of our integrations for larger customers. ","date":"2023-01-17","objectID":"/multiple-webhook-urls-in-one-payment-or-order/:2:0","tags":null,"title":"Multiple Webhook Urls in One Payment or Order","uri":"/multiple-webhook-urls-in-one-payment-or-order/"},{"categories":null,"content":"A workable solution (today) Enter MWM2. MWM2 is the second iteration of the Mollie Webhook Multiplexer. It’s a simple PHP/Symfony application, that reads in a configuration file containing a list of endpoints that should receive webhooks from Mollie. Users can configure whether path or query parameters should be preserved, and which HTTP Verb should be used (POST is very likely). The merchant then reconfigures the webhookUrl for their payments to point towards MWM2, and MWM2 clones and sends the webhooks to multiple systems described in the config file. The application is written in such a way that it’s easily extendable, for instance if the user wants to manipulate URLs or webhook data according to other variables. The application uses Symfony Messenger to put webhooks into a RabbitMQ, Redis, SQL, or whatever queue so they don’t need to be process synchronously (which considerably speeds up inbound webhook processing, and also ensures ultimate delivery, retries, and more for target systems). See the repository’s README.md for details. ","date":"2023-01-17","objectID":"/multiple-webhook-urls-in-one-payment-or-order/:3:0","tags":null,"title":"Multiple Webhook Urls in One Payment or Order","uri":"/multiple-webhook-urls-in-one-payment-or-order/"},{"categories":null,"content":"A workable solution (tomorrow) The limitations described above can be solved by introducing a Hooks or Events API to our current API offering. Put simply, a Hooks API would list all events occurring within the Mollie account that would trigger a webhook. By subscribing to this endpoint, the merchant or partner will be able to detect all important updates within their account and build the necessary automations within their platform, instead of constantly pulling potentially empty endpoints. Additionally, a Hooks or Events API (similar to those of Stripe and Adyen) is not something new; looking at our competitors, we can consider this to be a market standard. For the actual implementation within Mollie there are multiple possibilities. Here are a few examples: Events: An Events API will list all events within the Mollie account that would trigger a webhook. This API will list all events without any filtering from Mollie’s side. The event will contain parameters that will make it possible for the merchant to categorise. For example, a payment paid will generate a payment.paid. Using the events parameters, the customer is able to create customised pull requests or any business logic necessary. Events with filtering on Mollie side: Similar to the permission scope settings that can be created within the Mollie dashboard, the Events API could also be implemented with business logic on Mollie’s side. The setting will create a filtering on organisation or profile level for events listed when the merchant calls the events API. Webhook sent to multiple addresses: Creating the possibility to set up multiple webhooks is important. Here it is also important to add the possibility for the customer to manually set up webhooks or within the connect flow of a new integration to set up a new webhook for certain needed events. It should be noted that simply accepting multiple values will not work as there will be scenarios where software A would create the payments/customers etc. but software B would be pulling the data and would need the updates. Software A should not be responsible for creating the callback to software B. ","date":"2023-01-17","objectID":"/multiple-webhook-urls-in-one-payment-or-order/:4:0","tags":null,"title":"Multiple Webhook Urls in One Payment or Order","uri":"/multiple-webhook-urls-in-one-payment-or-order/"},{"categories":null,"content":"Replay Failed Webhook Calls Sometimes it happens that certain webhook calls fail and the merchant doesn’t really know why. We don’t log the response to the webhook call anywhere, but anyone can replay the webhook payloads (including the merchant themselves) to see any eventual error messages that might come back. Fire up a Terminal and run curl like so: $ curl -vv -d \"id=ord_2yr3ld\" -X POST https://backend.sporkify.net/webhooks/mollie-order/5c46d208c6513 Note: Unnecessary use of -X or --request, POST is already inferred. * Trying 172.67.9.147:443... * Connected to backend.sporkify.net (127.0.0.1) port 443 (#0) * ALPN: offers h2 * ALPN: offers http/1.1 * CAfile: /etc/ssl/cert.pem * CApath: none * (304) (OUT), TLS handshake, Client hello (1): * (304) (IN), TLS handshake, Server hello (2): * (304) (IN), TLS handshake, Unknown (8): * (304) (IN), TLS handshake, Certificate (11): * (304) (IN), TLS handshake, CERT verify (15): * (304) (IN), TLS handshake, Finished (20): * (304) (OUT), TLS handshake, Finished (20): * SSL connection using TLSv1.3 / AEAD-AES256-GCM-SHA384 * ALPN: server accepted h2 * Server certificate: * subject: C=US; ST=California; L=San Francisco; O=Cloudflare, Inc.; CN=sporkify.net * start date: Mar 8 00:00:00 2022 GMT * expire date: Mar 8 23:59:59 2023 GMT * subjectAltName: host \"backend.sporkify.net\" matched cert's \"*.sporkify.net\" * issuer: C=US; O=Cloudflare, Inc.; CN=Cloudflare Inc ECC CA-3 * SSL certificate verify ok. * Using HTTP2, server supports multiplexing * Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0 * h2h3 [:method: POST] * h2h3 [:path: /webhooks/mollie-order/5c46d208c6513] * h2h3 [:scheme: https] * h2h3 [:authority: backend.sporkify.net] * h2h3 [user-agent: curl/7.84.0] * h2h3 [accept: */*] * h2h3 [content-length: 13] * h2h3 [content-type: application/x-www-form-urlencoded] * Using Stream ID: 1 (easy handle 0x7ff03a80c600) \u003e POST /webhooks/mollie-order/5c46d208c6513 HTTP/2 \u003e Host: backend.sporkify.net \u003e user-agent: curl/7.84.0 \u003e accept: */* \u003e content-length: 13 \u003e content-type: application/x-www-form-urlencoded \u003e * We are completely uploaded and fine * Connection state changed (MAX_CONCURRENT_STREAMS == 256)! \u003c HTTP/2 403 \u003c date: Wed, 04 Jan 2023 16:06:25 GMT \u003c content-type: text/plain; charset=UTF-8 \u003c content-length: 16 \u003c x-frame-options: SAMEORIGIN \u003c referrer-policy: same-origin \u003c cache-control: private, max-age=0, no-store, no-cache, must-revalidate, post-check=0, pre-check=0 \u003c expires: Thu, 01 Jan 1970 00:00:01 GMT \u003c server: cloudflare \u003c cf-ray: 784538aa4c867276-HAM \u003c * Connection #0 to host backend.sporkify.net left intact error code: 1337 We might still not know what the error code means in all cases, but at least that’s info to move forward with. Note that this doesn’t work if the merchant has some form of Basic Auth in front of their shop. ","date":"2023-01-04","objectID":"/replay-failed-webhook-calls/:0:0","tags":null,"title":"Replay Failed Webhook Calls","uri":"/replay-failed-webhook-calls/"},{"categories":null,"content":"Where Do Test Credit Cards Come From? After an interesting discussion in the Discord (you can sign up here), I wanted to look a bit more into where Test Cards even come from. ","date":"2023-01-02","objectID":"/where-do-test-credit-cards-come-from/:0:0","tags":null,"title":"Where Do Test Credit Cards Come From","uri":"/where-do-test-credit-cards-come-from/"},{"categories":null,"content":"tl;dr They are proprietary per payment gateway. ","date":"2023-01-02","objectID":"/where-do-test-credit-cards-come-from/:1:0","tags":null,"title":"Where Do Test Credit Cards Come From","uri":"/where-do-test-credit-cards-come-from/"},{"categories":null,"content":"And now what? Assuming you’re familiar with the three and/or four party card schemes, you might be asking yourself, which of the parties involved controls the test cards. Rolling the process up backwards: The schemes/licensors: Would make sense. It’s where basically everything ends up at some point anyway, so why not have centralized test cards per brand/licensor? Issuer: Could also be, although every issuer (vulgo bank) would need to create their own cards, so downstream actors would need to know which card goes to which issuer (they know that, in theory, though). Gateway and/or Acquirer: First (or second) in line, so they could handle test cards efficiently, so upstream actors don’t need to be bothered with test stuff And the more you think about it, the more sense it makes to have test cards defined on a gateway level. Many test cards include a certain semantic about expected transaction state (e.g. by convention 4242 4242 4242 4242 or 4111 1111 1111 1111 would always create a successful transaction of sorts). Transaction state is simulated easily within the gateway’s system and doesn’t have to leave this context. Additionally, you might want to use test card numbers to control other behavior within the gateway (even functionalities that are not available on all payment gateways). Let’s look at a few examples: PAYONE: They have test cards with 3DS and some without 3DS, the latter set with a lot of mappings towards gateway-specific errors. Stripe: There’s a plethora of test cards available from Stripe, grouped by network/scheme, country, card type, fraud prevention logic, etc. Mollie: There’s one test card per network, the transaction state is not controlled by the test number, but rather by either selecting an outcome in the payment screen, which is also quite convenient. While it might be possible that some of the cards, if not all, work on other gateways (they usually are technically valid), a card that triggers an error on Stripe might work just fine on Mollie. ","date":"2023-01-02","objectID":"/where-do-test-credit-cards-come-from/:2:0","tags":null,"title":"Where Do Test Credit Cards Come From","uri":"/where-do-test-credit-cards-come-from/"},{"categories":null,"content":"Magento 2: Webhooks of External Changes Apparently external changes are not recognized corrently by the Magento 2 extension. If, for example, you have a setup according to the ideal flow and the ERP partially ships an order, those line items are not updated by the webhook Mollie then sends. Even worse, it might lead to 500 errors that both confuse Mollie technical support and merchants alike. Updating the order state (see also state vs. status) might also create unwanted API calls towards Mollie, because an observer might trigger a capture or refund, so that’s also not ideal. An idea (not implemented) would be to have some general modes in webhook handling in combinations with a downstream ERP: Leading mode: All state changes (both order lines and orders) are to be sent to Mollie as Captures/Refunds; incoming webhooks are not incorporated into state changes Consuming mode: Incoming webhooks trigger updates in order line or order state; incoming state changes are purely informational Leading mode would be useful for setups where there is no direct connection between the Order Management System and Mollie. Consuming Mode is, subsequently, for setups where the Order Management System drives changes at the Mollie API. We’d need to make a plan how this ties in with connected processes, e.g. generation of invoices etc. ","date":"2022-12-20","objectID":"/magento-2-webhooks-of-external-changes/:0:0","tags":null,"title":"Magento 2 Webhooks of External Changes","uri":"/magento-2-webhooks-of-external-changes/"},{"categories":null,"content":"Sequence Diagram of Typical Recurring Cases This swimlanes.io sequence diagram displays the two main possibilities how to run recurring transactions with Mollie. There are two typical options Use the recurring functionality on Mollie Platform Use a Recurring Backend like Chargebee, ReCharge, Billwerk, your online shop, etc. or DIY (“charge on demand”) You can find the original swimlane.io Diagram here https://swimlanes.io/u/H_N-KgHp1 ","date":"2022-12-09","objectID":"/recurring-setups-with-mollie/:0:0","tags":null,"title":"Recurring Setups With Mollie","uri":"/recurring-setups-with-mollie/"},{"categories":null,"content":"General Mollie Setup This swimlane.io sequence diagram includes a webshop, an ERP solution (order management) and an accounting tool. It displays the communication between the various systems and Mollie. The most up to date version can be found here: https://swimlanes.io/u/oo5tTmId8 ","date":"2022-12-09","objectID":"/sequence-diagram-of-a-general-mollie-setup/:0:0","tags":null,"title":"Sequence Diagram of a General Mollie Setup","uri":"/sequence-diagram-of-a-general-mollie-setup/"},{"categories":null,"content":"What does the Klarna invoice email look like Many merchants ask about the consumer experience when using Klarna invoice, specifically how the consumer recieves the IBAN and bank details. We will not return the IBAN on API level (as e.g. RatePay does), as Klarna does not follow this type of white label approach. They want to position their brand directly towards the consumer. At a minimum, the consumer will receive an email that looks like this Additionally, if the consumer uses the Klarna App, they will find their due payment there as well, and can also choose to pay via Direct Debit, move the due date, pay in installments, and much more. There is no need to print the IBAN from Klarna on the merchant invoice. This will only confuse consumers, as they are typically used to this. Merchant should clearly state on their invoices that payment is needs to go to Klarna, and not the merchant’s bank account. ","date":"2022-12-07","objectID":"/klarna-iban-invoice-email/:0:0","tags":null,"title":"Klarna Iban Invoice Email","uri":"/klarna-iban-invoice-email/"},{"categories":null,"content":"How to connect your PayPal Account to Mollie Log in to Mollie Dashboard Settings \u003e Profiles \u003e Desired Profile Activate the toggle next to PayPal, should look like this: Click the button, get redirected to PayPal, enter PayPal Business email Then login normally There might be a permissions screen Finally, there should be a confirmation: Looks like this when you click the button and go back to Mollie ","date":"2022-12-07","objectID":"/how-to-connect-paypal-to-mollie/:0:0","tags":null,"title":"How to Connect Paypal to Mollie","uri":"/how-to-connect-paypal-to-mollie/"},{"categories":null,"content":"Server to Server Card Tokenization with Mollie Mollie in theory has an endpoint for server-to-server card tokenization. In order to have this explained to you, you have to provide a valid PCI DSS Attestation of Compliance. This endpoint is, unfortunately, not suitable for card tokenization from an App context, as the Access-Control-Allow-Origin HTTP Header prevents this (I think, I don’t really do frontend). See the Further Reading sections for In-App alternatives. Upon further consideration, it might certainly be possible to ignore the Access-Control-Allow-Origin Header in App contexts - someone would need to try this out and tell me about it. ","date":"2022-12-06","objectID":"/server-to-server-credit-card-tokenization/:0:0","tags":null,"title":"Server to Server Credit Card Tokenization","uri":"/server-to-server-credit-card-tokenization/"},{"categories":null,"content":"Further reading Mollie Demo Checkout for iOS: https://github.com/mollie/demo-checkout-ios Mollie Demo Checkout for Android: https://github.com/mollie/demo-checkout-android Mollie Demo Checkout Backend: https://github.com/mollie/demo-checkout-backend ","date":"2022-12-06","objectID":"/server-to-server-credit-card-tokenization/:1:0","tags":null,"title":"Server to Server Credit Card Tokenization","uri":"/server-to-server-credit-card-tokenization/"},{"categories":null,"content":"Webhook calls fail with 401 Unauthorized The merchant probably is using a .htaccess file to restrict access to their stage environment. In order for our webhooks to get delivered, the merchant needs to add our IP addresses to the allow-list. ","date":"2022-12-06","objectID":"/webhook-401-htaccess/:0:0","tags":null,"title":"Webhook 401 Htaccess","uri":"/webhook-401-htaccess/"},{"categories":null,"content":"How to add IP addresses to the allow list See here. ","date":"2022-12-06","objectID":"/webhook-401-htaccess/:1:0","tags":null,"title":"Webhook 401 Htaccess","uri":"/webhook-401-htaccess/"},{"categories":null,"content":"What are Mollie’s IP addresses? See our help center ","date":"2022-12-06","objectID":"/webhook-401-htaccess/:2:0","tags":null,"title":"Webhook 401 Htaccess","uri":"/webhook-401-htaccess/"},{"categories":null,"content":"Magento 2: Status vs. State Ah yes, the joy of Magento’s “Status vs. State”. It’s actually funny, if it wasn’t so sad. And also the slight dyslexia (and/or lack of command of the Latin language) of the person who wrote the response doesn’t help either. Let’s think this through. Capitalized nouns indicate Magento concepts. fixed width font indicates a fixed technical term. ","date":"2022-12-06","objectID":"/magento-2-state-vs-status/:0:0","tags":null,"title":"Magento 2 State vs Status","uri":"/magento-2-state-vs-status/"},{"categories":null,"content":"There is State: Orders have States. State denotes what technically currently is happening to the order (eg. processing meaning an Order is being prepared but isn’t complete yet). There actually is a fairly simple default state machine for Order States: new -\u003e processing -\u003e complete. Those are the mandatory States. The others are there for eventualities, like waiting for async payment, or for fully refunded Orders. The States are fixed, you can’t add new arbitrary ones. They trigger certain events within Magento as well, like Invoice creation. States can have a label, but that is typically only visible in the backend. ","date":"2022-12-06","objectID":"/magento-2-state-vs-status/:1:0","tags":null,"title":"Magento 2 State vs Status","uri":"/magento-2-state-vs-status/"},{"categories":null,"content":"Then there is Status (which the provider of the answer spells “states”): A Status builds on top of the core concept of Order State, and is intended to give more information to consumers or store owners about what’s happening to an Order, beyond the scope of the limited Order State Machine. It’s merely a label and has no bearing on the core business processes happening to an order (e.g. you cannot generate an Invoice from an Order hitting a certain Status alone, you’d need to transition it to a State in order to trigger that. You can set Order Status conditionally, e.g. only for Orders with a selected Payment Method. Let’s consider two examples: Order with Credit Card: The Order is created (State new), we confirm the Payment, and State now is processing. A potential Status here could be “Payment received”. The Order would get shipped and State would turn to completed. Order on invoice (not BNPL, let’s assume classic invoice payment): The Order is created (State new), but no payment has been made yet. Order State progresses directly to processing, but Status here would rather be something like “Order has been shipped”. We could even read out the package delivery API and set Status to “Order delivered at dd-mm-yyyy, awaiting invoice payment”, while the Order State remains in processing. Only when the invoice payment is received, we set State to completed. Hope the examples illustrate why you need Status while maintaining the same State Machine. ","date":"2022-12-06","objectID":"/magento-2-state-vs-status/:2:0","tags":null,"title":"Magento 2 State vs Status","uri":"/magento-2-state-vs-status/"},{"categories":null,"content":"Further reading https://magecomp.com/blog/difference-magento-order-status-order-state-magento-2/ https://experienceleague.adobe.com/docs/commerce-admin/stores-sales/order-management/orders/order-status.html ","date":"2022-12-06","objectID":"/magento-2-state-vs-status/:3:0","tags":null,"title":"Magento 2 State vs Status","uri":"/magento-2-state-vs-status/"},{"categories":null,"content":"Accounting with Mollie In the following, I will explain how, from my point of view, accounting for Mollie payments should be done by default (my accounts are only borrowed from SKR04 as an example) ","date":"2021-10-21","objectID":"/accounting-with-mollie-fundamentals/:0:0","tags":null,"title":"Accounting With Mollie Fundamentals","uri":"/accounting-with-mollie-fundamentals/"},{"categories":null,"content":"Chart of accounts 4000 Income 69999 Customer 1300 Receivables from Mollie 1460 Payments in transit 1700 Bank 6850 Costs of monetary transactions ","date":"2021-10-21","objectID":"/accounting-with-mollie-fundamentals/:1:0","tags":null,"title":"Accounting With Mollie Fundamentals","uri":"/accounting-with-mollie-fundamentals/"},{"categories":null,"content":"Import of orders and payments (accounts receivable), triggered by the event “New order” Import of orders from Shop/ERP: Here a posting record Debtor to Revenue is created, for example: 100€ 69999 to 4000: Import of payment from Mollie (here it is important that the payment has also already been made, so there is also a capture at Klarna): Receivables against Mollie to debtor, 100€ 1300 to 69999: The debtor is now credited and the receivable against Mollie has increased. Of course, this is now repeated several times for all sales and payments. ","date":"2021-10-21","objectID":"/accounting-with-mollie-fundamentals/:1:1","tags":null,"title":"Accounting With Mollie Fundamentals","uri":"/accounting-with-mollie-fundamentals/"},{"categories":null,"content":"Import of a settlement, triggered by the event “Mollie creates a settlement” Retrieving the settlement from the API, here a posting record Payment in transit to Receivables against Mollie is created, for example 95€ 1460 to 1300: So now we expect a payment receipt from Mollie on the bank in the amount of 95€. The missing 5€ are exemplarily the fees that Mollie has withheld in the context of this payment. However, these are not yet fixed, since we have not yet received a receipt from Mollie for the fees. The payments or captures contained in the settlement can be retrieved and reconciled via the corresponding endpoints below the settlement. This is now repeated whenever Mollie generates a new settlement according to the payout frequency. ","date":"2021-10-21","objectID":"/accounting-with-mollie-fundamentals/:1:2","tags":null,"title":"Accounting With Mollie Fundamentals","uri":"/accounting-with-mollie-fundamentals/"},{"categories":null,"content":"Posting of the Mollie disbursement, triggered by the event “A Mollie disbursement transaction is in bank import” Here, a posting record bank to disbursement in transit is created, for example €95 1700 to 1460: So the expected settlement is now posted, we do not expect any further payment from Mollie until a new settlement is generated. ","date":"2021-10-21","objectID":"/accounting-with-mollie-fundamentals/:1:3","tags":null,"title":"Accounting With Mollie Fundamentals","uri":"/accounting-with-mollie-fundamentals/"},{"categories":null,"content":"Posting of payment fees, triggered by the event “Mollie issues an invoice” on the first business day of a month for the period of the previous month Retrieving the invoice via the API or the PDF document from the dashboard. This is where the posting record Cost of Money Transactions to Receivables against Mollie is created, for example €5 6850 to 1300: Most likely, there is also an “Invoice Compensation” line item on the invoice that adjusts rounding differences in your favor when calculating the charges. ","date":"2021-10-21","objectID":"/accounting-with-mollie-fundamentals/:1:4","tags":null,"title":"Accounting With Mollie Fundamentals","uri":"/accounting-with-mollie-fundamentals/"},{"categories":null,"content":"Webinar: Mollie loves PWA “Mollie loves PWA” was a webinar held in September 2021 on PWA technologies specifically for Magento 2. ","date":"2021-09-23","objectID":"/mollie-loves-pwa/:1:0","tags":null,"title":"Mollie Loves Pwa","uri":"/mollie-loves-pwa/"},{"categories":null,"content":"Webinar: Technology fundamentals - HTTP In this webinar HTTP is explained. It’s one of the most fundamental web technologies, and the basis for RESTful APIs: ","date":"2021-02-24","objectID":"/technology-fundamentals-http/:1:0","tags":null,"title":"Technology Fundamentals Http","uri":"/technology-fundamentals-http/"}]